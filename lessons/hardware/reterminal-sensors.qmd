---
title: "reTerminal Sensors"
subtitle: Installing initial reTerminal packages. Reading and controlling the reTerminal hardware interfaces, e.g. LEDs, light sensor, screen backlight, etc.
order: 1
---

## Lab 1 Review

After Lab 1, you have taken the following steps:

1. Install the Raspberry Pi OS image.
 - disassemble, flip the memory switch and use `usbboot/rpiboot` script to prepare internal memory for firmware flash.
 - use Raspberry Pi Imager to flash new image 64bit "Bookworm" Raspberry OS with chosen username/password and SSH enabled
 - fix the "black screen" issue by installing the latest seeed overlay drivers

2. Update system packages
 - update system repositories with `sudo apt update` and `sudo apt upgrade`
 - install kernel headers with `sudo apt install raspberrypi-kernel-headers`
 - install `git` and `docker`, deploy simple Python webserver docker container

3. Set up remote connection interfaces
 - determine your assigned IP address on the class LAN
 - determine your device MAC address
 - enable VNC interface

It's time to take a deeper look at the hardware and software our reTerminal offers.

## Hardware

*This section is adapted directly from the reTerminal wiki: ["Getting Started with reTerminal"](https://wiki.seeedstudio.com/reTerminal/#features)*

The reTerminal is powered by a Raspberry Pi Compute Module 4 (CM4) which is
a Quad-Core Cortex-A72 CPU running at 1.5GHz and a 5-inch IPS capacitive
multi-touch screen with a resolution of 1280 x 720. It has sufficient
amount of RAM (4GB) to perform multitasking and also has sufficient
amount of eMMC storage (32GB) to install an operating system, enabling
fast boot up times and smooth overall experience. It has wireless
connectivity with dual-band 2.4GHz/5GHz Wi-Fi and Bluetooth 5.0 BLE.

reTerminal consists of a high-speed expansion interface and rich I/O for
more expandability. This device has security features such as a
cryptographic co-processor with secure hardware-based key storage. It
also has built-in modules such as an accelerometer, light sensor and an
RTC (Real-Time Clock). reTerminal has a Gigabit Ethernet Port for faster
network connections and also has dual USB 2.0 Type-A ports. The 40-pin
header on the reTerminal opens it for a wide range of IoT applications.

### Firmware & Version

------------------------------------------------------------------------------------
Released Date  Pre-Installed OS                       Pre-Installed   Board Version  
                                                      STM32 Firmware                 
-------------- -------------------------------------- --------------- --------------
06/15/2021     2021-06-02-Raspbian(modified)-32-bit   V1.0            v1.3          

08/03/2021     2021-06-02-Raspbian(modified)-32-bit   V1.1            v1.4          

09/03/2021     2021-06-02-Raspbian(modified)-32-bit   V1.6            v1.6          

11/02/2021     2021-09-14-Raspbian(modified)-32-bit   V1.8            v1.6          

**Winter 2024**   **What OS did we install in Lab 1?**       V1.8            v1.6
------------------------------------------------------------------------------------

**You can find a complete list of the reTerminal specifications here: [reTerminal Specifications](https://wiki.seeedstudio.com/reTerminal/#specifications)**

## Raspberry Pi OS and Debian

The Raspberry Pi OS (previously called *Raspbian OS*) used in the reTerminal is a variation of the [**Debian OS**](https://en.wikipedia.org/wiki/Debian), with optimizations for the Raspberry Pi hardware.

> **Debian OS** is one of the most commonly used Linux distributions, especially as the "base" for derivative distributions. There are over 100 derivatives of Debian, many of which are themselves very popular distributions. These include:
>
> - Desktop distributions like Ubuntu, Linux Mint, elementaryOS;
> - Special-purpose distributions Kali Linux and Backbox (penetration testing)
> - Server/Hypervisor distributions like Proxmox, Ubuntu server, 
> - Many others, you can find a more complete list [here](https://en.wikipedia.org/wiki/List_of_Linux_distributions#Debian-based)

Debian-derived distributions share the following:
- the `.deb` package format 
- the `dpkg` package manager and its frontend `apt`

For that reason, many of the commands and configuration for Raspberry Pi OS can be taken directly from Debian's documentation.

### Apt: Debian Package Manger

The command `apt` is the default package manager of Debian.

> A **package manager** is a software tool responsible for automating the installation, removal, configuration and removal of computer programs.

Managing packages could technically be done manually, however, it is very time consuming and error prone: tracking package dependencies and compatibility with the current system. 

Note: `apt` is a newer package manager API meant to replace the older API  `apt-get`. However, they both accomplish the same. See [Debian docs](https://www.debian.org/doc/manuals/debian-handbook/sect.apt-get.en.html) for details.

During Lab 1, you updated, upgraded and installed some packages in the Raspberry Pi OS using `apt`:

| Command                 | Description                                                        |
| ----------------------- | ------------------------------------------------------------------ |
| `sudo apt update`       | Update list of available packages |
| `sudo apt upgrade`      | Upgrade the system by installing/upgrading packages |

Other commonly used commands, as seen from running `apt --help`:

| Command | Description |
| ------- | ----------- |
| `apt list` | list packages based on package names |
| `apt search` | search in package descriptions |
| `apt show <package>` | show package details |
| `apt install <package>` | install packages |
| `apt reinstall <package>` | reinstall packages |
| `apt remove <package>` | remove packages |
| `apt autoremove` | Remove automatically all unused packages |
| `apt full-upgrade` | upgrade the system by removing/installing/upgrading packages |
| `apt edit-sources` | edit the source information file |

Note: documentation will often leave out `sudo` since the need to run `sudo` depends on the machine and the user. 

>
> In general, commands that **read** data (`apt list`, `apt search`, etc.) will generally not require `sudo`, since most folderst that `apt` will touch are universally readable.
>
> `apt` commands that **write** data (`apt install`, etc.) to a folder not owned by the current user -- which is most folders outside of `/home/username`, but particularly common package install locations like `/usr`, `/bin`, etc. -- these commands will require `sudo` to gain the required write permission

<!-- ### Pip: Python Package Manager -->
<!---->
<!-- [`pip`](https://pip.pypa.io/en/stable/) is python's own package manager, which is independent from `apt`.  -->
<!---->
<!-- > Pip installs packages from the [Python Package Index repository (pypi.org)](https://pypi.org/) -->
<!---->
<!-- To use it for python 3, call the command `pip3` -->
<!---->
<!-- ```bash -->
<!-- pip3 install emoji -->
<!-- ``` -->
<!---->
<!-- This will install the a python library emoji which will create emoji from text descriptions. -->
<!---->
<!-- Once a python module has been installed, it is available to be imported in your python script: -->
<!---->
<!-- ```python -->
<!-- import emoji -->
<!---->
<!-- message = emoji.emojize('Howdy :sun_with_face:') -->
<!-- print(message) -->
<!-- ``` -->
<!---->
<!-- Output: -->
<!---->
<!-- ```bash -->
<!-- Howdy ðŸŒž -->
<!-- ``` -->
<!---->
<!-- It is also possible to give an alias to the newly imported module: -->
<!---->
<!-- ```python -->
<!-- import emoji as em -->
<!---->
<!-- message = em.emojize('Howdy :sun_with_face:') -->
<!-- print(message) -->
<!-- ``` -->
<!---->
<!-- Finally, you can import only a specific function and give it an alias: -->
<!---->
<!-- ```python -->
<!-- from emoji import emojize as emz -->
<!-- message = emz('Howdy :sun_with_face:') -->
<!-- print(message) -->
<!-- ``` -->
<!---->
<!-- ### apt vs pip: when to use which? -->
<!---->
<!-- > Note: do not run `pip` as `sudo` because `pip` could overwrite system files that are managed by `apt`. -->
<!---->

## Reading sensor data in Linux

*This section is based on the official documentation for the reTerminal: [Hardware and Interfaces Usage](https://wiki.seeedstudio.com/reTerminal-hardware-interfaces-usage/#3-user-programmable-leds)*

> In Linux, everything is a file stream that can be read and/or written to.

For example, keyboard inputs and communication over web-sockets are all read as a file streams.

The reTerminal has 3 programmable LED's and a light sensor that can be **controlled like a regular file**.

![](../assets/5-reterminal-buttons-light-sensor.png)

## Sensors

### Programmable LEDs

There are 3 programmable LEDs in the reTerminal:

- **STA** light can be turned on as **red or green**.
- **USR** light can only be turned on as **green**.

![](../assets/5-reterminal_leds.png ':size=400')

The lights can be controlled at the OS level by editing files in the `/sys/class/leds/` directory. Use `ls -al` to list the files in this directory:

```bash
username@hostname:/sys/class/leds/usr_led0 $ ls -al
total 0            
drwxr-xr-x 3 root root    0 Jan 25 20:33 .               
drwxr-xr-x 8 root root    0 Jan 25 20:33 ..                                                                                                                                                                         
-rw-r--r-- 1 root root 4096 Jan 26 22:02 brightness                                                                                                                                                                 
```
![Unix Permissions cheatsheet py Julia Evans](../assets/5-unix-permissions-cheatsheet.png)
<p class=img-info>
    <a href="https://drawings.jvns.ca/permissions/"> Unix File Permissions,</a>&nbsp; Julia Evans.
</p>

The `brightness` file inide the `usr_led0` controls the brightness of LED0. But, because only `root` has write permissions to this file, we will likely run into permissions errors if we try to edit the value directly:

```
$ nano /sys/class/leds/usr_led0
Permission denied
$ echo 255 > /sys/class/leds/usr_led0
Permission denied
$ sudo echo 255 > /sys/class/leds/usr_led0
```

There are a few possible approaches to this problem:

### Use sudo + text-editor

### Use sudo + su

Enable root account privileges (take the identity of the root user)

```bash
$ sudo su
```

Your shell should now display `root@hostname:~# `

Turn on the LED with maximum brightness

```bash
# echo 255 > brightness
```

Turn off the LED

```bash
# echo 0 > brightness
```

Similarly, you can control  `usr_led1` and `usr_led2` and even the buzzer on `/sys/class/leds/usr_buzzer`
### Use sudo + `tee`

**Note:** We'll run the next command as root because the file we want to write belongs the system (`root` user, rather than to the user `pi`.


### Luminosity Sensor

The digital light sensor can read the surrounding light levels.

1. Enter the following directory

```bash
cd /sys/bus/iio/devices/iio:device0
```

2. Read the following file to obtain the light intensity value in **Lux**

```bash
cat in_illuminance_input 
```

Output:
```bash
pi@raspberrypi:/sys/bus/iio/devices/iio:device0 $ cat in_illuminance_input 
2719
```

**Note:** We don't need to be root to read this file. Its permissions are set to let all users read it, even-though it belongs to the root user:

```bash
rw-r--r-- 1 root root 4096 Jan 30 22:16 in_illuminance_input
```

## Python Library for reTerminal

Seeed Studio provided a python library to access most of the sensors and actuators of the reTerminal.


Install the library `seeed-python-reterminal` (see official [Github repo](https://github.com/Seeed-Studio/Seeed_Python_ReTerminal)) using `pip`:

```bash
sudo pip3 install seeed-python-reterminal
```

> **Installing pip libraries as root is not recommended.**
>
> **However**, this library needs to access system files (see previous section) and will have to be executed as root.
>
> There are workarounds, however, for simplicity we will install this package as root. See section *ModuleNotFoundError* below for more context.

Now you can import it to a test script (eg. *buzz.py*)

```python
import seeed_python_reterminal.core as rt
import time

print("BUZZER ON")
rt.buzzer = True
time.sleep(1)

print("BUZZER OFF")
rt.buzzer = False
```

This will sound the buzzer of the reTerminal for 1 second.

To run the script:
```bash
sudo python3 buzz.py
```

Alternatively, first elevate your shell, then execute the script normally:
```bash
pi@raspberrypi:~ $ sudo -i
root@raspberrypi:~# python3 buzz.py
```

> **Note:** this library is simply a wrapper to the OS operations we did in the previous section.
> Some files need to be accessed by python as root. In this case, it is necessary to run `sudo -i` **before running** the python script.


See the official `seeed-python-reterminal` [Github repo](https://github.com/Seeed-Studio/Seeed_Python_ReTerminal) for API reference on how to control:

- LED's
- Accelerometer
- Programmable Buttons
- Light Sensor (requires manual updating)


### ModuleNotFoundError

When trying to import the  `seeed-python-reterminal`  library, you might get the following error:

```bash
ModuleNotFoundError: No module named 'seeed_python_reterminal'
```

The python interpreter is not able to find the module even though it is installed.

You can run the checks described below.

#### Check library location

Check the location of where the module was installed with `pip3 show <module-name>`:

```bash
pi@raspberrypi:~ $ pip3 show seeed-python-reterminal

Name: seeed-python-reterminal
Version: 0.2
Summary: seeed-python-reterminal
Home-page: https://github.com/Seeed-Studio/Seeed_Python_ReTerminal
Author: Takashi Matsuoka (matsujirushi)
Author-email: matsujirushi@live.jp
License: MIT License
Location: /usr/local/lib/python3.7/dist-packages      # Library location
Requires: evdev
Required-by: 
```

The library is installed at: `Location: /usr/local/lib/python3.7/dist-packages`


#### Check python's library paths

Similarly to Linux, there are environmental variables that determine where python will look for installed modules/libraries.

See the paths where python is looking for libraries with `sys.path`.

```python
pi@raspberrypi:~ $ python3

>>> import sys      # Exposes configuration used by the python interpreter.
>>> sys.path        # Lists all paths where interpreter looks for modules.
[
 '',
 '/usr/lib/python37.zip',
 '/usr/lib/python3.7',
 '/usr/lib/python3.7/lib-dynload',
 '/home/pi/.local/lib/python3.7/site-packages',
 '/usr/local/lib/python3.7/dist-packages',
 '/usr/lib/python3/dist-packages'
]
```

If the output of `pip3 show seeed-python-reterminal` is not in this list, python will not find it when you import it.

> **Note:** the python shell above was started as the user `pi`.
> If you start python as **root**, `sys.path` might have different paths.

Below, python was started as **root**:

```python
pi@raspberrypi:~ $ sudo -i
root@raspberrypi:~# python3

>>> import sys
>>> sys.path
[
'',
'/usr/lib/python37.zip',
'/usr/lib/python3.7',
'/usr/lib/python3.7/lib-dynload',
'/usr/local/lib/python3.7/dist-packages',
'/usr/lib/python3/dist-packages'
]
```

Note that the user `pi` does not have permission to add content inside `/usr`.
Thus, all `pip` installations as the regular user go into `/home/pi/.local/lib/python3.7/site-packages`.

**Conclusion:** if you install a python library as `root`, it might go to a different directory compared to installing it as the regular user.

This is the main reason why we chose to install the `seeed-python-reterminal` as root, rather than the regular user `pi`.

### Making user's library available to root (optional)

If you would like to make a library installed as the user `pi` available when running the script as `root`, you will need to export an environmental variable named `PYTHONPATH` pointing to the library location.

For example, assuming that a library installed under the user `pi` is located in `/home/pi/.local/lib/python3.7/site-packages`, do the following:

```bash
# Elevate the shell to the root user
pi@raspberrypi:~ $ sudo -i
root@raspberrypi:~#

# Export the PYTHONPATH environment variable
root@raspberrypi:~# export PYTHONPATH="/home/pi/.local/lib/python3.7/site-packages"

# Start python as root and run the script that imports the library
root@raspberrypi:~# python3 my_script.py
```
