---
title: "Package management in Python"
subtitle: How to use OS package managers, virtual environments, and `pip` to manage python applications effectively.
---

## Pip: Python Package Manager

[`pip`](https://pip.pypa.io/en/stable/) is python's own package manager, which is independent from `apt`. 

> Pip installs packages from the [Python Package Index repository (pypi.org)](https://pypi.org/)

### Overview

In the big picture, `pip` *feels* similar to other package managers like `apt`, where you can install/uninstall/update packages from the CLI.

```bash
pip install emoji
```

This will install the a python library emoji -- you can then `import` that package in python scripts to create emojis from text descriptions.

Once a python module has been installed, it is available to be imported in your python script:

```python
import emoji

message = emoji.emojize('Howdy :sun_with_face:')
print(message)
```

Output:

```bash
Howdy ðŸŒž
```

It is also possible to give an alias to the newly imported module:

```python
import emoji as em

message = em.emojize('Howdy :sun_with_face:')
print(message)
```

Finally, you can import only a specific function and give it an alias:

```python
from emoji import emojize as emz
message = emz('Howdy :sun_with_face:')
print(message)
```

## Creating virtual environments with `venv`

Unfortunately, the commands shown in the previous section don't work on all systems for all users -- python packages can be for the whole **system**, or just some **users**; moreover, systems and even users can have multiple versions of python installed on the same machine. Where is the package installed? What if there are version conflicts?

The best practise these days to manage python dependencies is to **isolate project dependencies in a virtual environment**. In a **virtual environment**, a python installation is separated from the system and other user installs. You can have many python virtual environments that are all isolated from eachother, each with different dependencies and even versions of python.

Creation of virtual environments is done by executing the command venv:

```bash
python -m venv env
```

The final argument (`env` above) is the *target directory* for the virtual environment.



## apt vs pip: when to use which?

> Note: do not run `pip` as `sudo` because `pip` could overwrite system files that are managed by `apt`.

### ModuleNotFoundError

When trying to import the  `seeed-python-reterminal`  library, you might get the following error:

```bash
ModuleNotFoundError: No module named 'seeed_python_reterminal'
```

The python interpreter is not able to find the module even though it is installed.

You can run the checks described below.

### Check library location

Check the location of where the module was installed with `pip3 show <module-name>`:

```bash
pi@raspberrypi:~ $ pip3 show seeed-python-reterminal

Name: seeed-python-reterminal
Version: 0.2
Summary: seeed-python-reterminal
Home-page: https://github.com/Seeed-Studio/Seeed_Python_ReTerminal
Author: Takashi Matsuoka (matsujirushi)
Author-email: matsujirushi@live.jp
License: MIT License
Location: /usr/local/lib/python3.7/dist-packages      # Library location
Requires: evdev
Required-by: 
```

The library is installed at: `Location: /usr/local/lib/python3.7/dist-packages`


#### Check python's library paths

Similarly to Linux, there are environmental variables that determine where python will look for installed modules/libraries.

See the paths where python is looking for libraries with `sys.path`.

```python
pi@raspberrypi:~ $ python3

>>> import sys      # Exposes configuration used by the python interpreter.
>>> sys.path        # Lists all paths where interpreter looks for modules.
[
 '',
 '/usr/lib/python37.zip',
 '/usr/lib/python3.7',
 '/usr/lib/python3.7/lib-dynload',
 '/home/pi/.local/lib/python3.7/site-packages',
 '/usr/local/lib/python3.7/dist-packages',
 '/usr/lib/python3/dist-packages'
]
```

If the output of `pip3 show seeed-python-reterminal` is not in this list, python will not find it when you import it.

> **Note:** the python shell above was started as the user `pi`.
> If you start python as **root**, `sys.path` might have different paths.

Below, python was started as **root**:

```python
pi@raspberrypi:~ $ sudo -i
root@raspberrypi:~# python3

>>> import sys
>>> sys.path
[
'',
'/usr/lib/python37.zip',
'/usr/lib/python3.7',
'/usr/lib/python3.7/lib-dynload',
'/usr/local/lib/python3.7/dist-packages',
'/usr/lib/python3/dist-packages'
]
```

Note that the user `pi` does not have permission to add content inside `/usr`.
Thus, all `pip` installations as the regular user go into `/home/pi/.local/lib/python3.7/site-packages`.

**Conclusion:** if you install a python library as `root`, it might go to a different directory compared to installing it as the regular user.

This is the main reason why we chose to install the `seeed-python-reterminal` as root, rather than the regular user `pi`.

### Making user's library available to root (optional)

If you would like to make a library installed as the user `pi` available when running the script as `root`, you will need to export an environmental variable named `PYTHONPATH` pointing to the library location.

For example, assuming that a library installed under the user `pi` is located in `/home/pi/.local/lib/python3.7/site-packages`, do the following:

```bash
# Elevate the shell to the root user
pi@raspberrypi:~ $ sudo -i
root@raspberrypi:~#

# Export the PYTHONPATH environment variable
root@raspberrypi:~# export PYTHONPATH="/home/pi/.local/lib/python3.7/site-packages"

# Start python as root and run the script that imports the library
root@raspberrypi:~# python3 my_script.py
```

