[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home",
    "section": "",
    "text": "This companion site for the 420-6P3 course includes:\n\n\nLecture slides / documents\nExercises\nReferences & Resources\n\n\nWebsite accessible at john-abbott-college.github.io/6P3-Notes\n\n\nThis course will introduce students to the principles of the Internet of Things (IoT). Students will use Linux and Python to program a Raspberry Pi in order to read data from sensors and control actuators.\nBy the end of the course, students build and deploy an IoT product that is securely connected to the Azure ecosystem in order to collect and analyse telemetry data as well as respond to remote commands.\n\n\n\n\nExperience using Object Oriented Programming to create applications in any language.\nFamiliarity using the Bash shell and basic Linux CLI.\nFamiliarity with Python.\nA Raspberry Pi with various sensors and actuators (see page Hardware List).\nA Microsoft Azure account: create a free Azure for Students account if necessary.\nVS Code configured for Python programming and remote development (see page Dev Setup).\n\n\n\n\nThis webpage is written in Markdown using the Quarto framework. The website is hosted via GitHub Pages\nSource code is open source and available on GitHub.\n\n\nCreate a local copy of these notes:\n\nInstall Quarto for your system\nClone the course GitHub repository.\nPreview the website:\nquarto preview .\n\n\nThis work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License. See the Copyright statement on the course webpage."
  },
  {
    "objectID": "index.html#description",
    "href": "index.html#description",
    "title": "Home",
    "section": "",
    "text": "This course will introduce students to the principles of the Internet of Things (IoT). Students will use Linux and Python to program a Raspberry Pi in order to read data from sensors and control actuators.\nBy the end of the course, students build and deploy an IoT product that is securely connected to the Azure ecosystem in order to collect and analyse telemetry data as well as respond to remote commands."
  },
  {
    "objectID": "index.html#requirements",
    "href": "index.html#requirements",
    "title": "Home",
    "section": "",
    "text": "Experience using Object Oriented Programming to create applications in any language.\nFamiliarity using the Bash shell and basic Linux CLI.\nFamiliarity with Python.\nA Raspberry Pi with various sensors and actuators (see page Hardware List).\nA Microsoft Azure account: create a free Azure for Students account if necessary.\nVS Code configured for Python programming and remote development (see page Dev Setup)."
  },
  {
    "objectID": "index.html#source-code",
    "href": "index.html#source-code",
    "title": "Home",
    "section": "",
    "text": "This webpage is written in Markdown using the Quarto framework. The website is hosted via GitHub Pages\nSource code is open source and available on GitHub.\n\n\nCreate a local copy of these notes:\n\nInstall Quarto for your system\nClone the course GitHub repository.\nPreview the website:\nquarto preview .\n\n\nThis work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License. See the Copyright statement on the course webpage."
  },
  {
    "objectID": "reference/docs/course-hardware.html",
    "href": "reference/docs/course-hardware.html",
    "title": "Course Hardware",
    "section": "",
    "text": "The reTerminal is a development board based on the Raspberry Pi Compute Module 4 (CM4) manufactured by Seeed Studio.\n\n\n\n\n\nThe reTerminal device.\n\n\nNotable features:\n\nCompute Module 4 with 4GB RAM & 32GB eMMC\n5-Inch IPS capacitive multi-touch screen at 1280 x 720 and 293 PPI\nWireless connectivity with dual-band 2.4GHz/5GHz Wi-Fi and Bluetooth 5.0 BLE\nCryptographic co-processor with secure hardware-based key storage\nBuilt-in modules such as accelerometer, light sensor, and RTC\n\n\nSee reTerminal Wiki page for detailed specs and documentation\n\n\n\n\n\n\n\n\nRPI USB-C POWER SUPPLY BLACK US\n\n\nThe reTerminal requires a power supply that can provide a minimum of 3 Amps. The official Raspberry Pi USB-C Power Supply in included in the kit."
  },
  {
    "objectID": "reference/docs/course-hardware.html#reterminal",
    "href": "reference/docs/course-hardware.html#reterminal",
    "title": "Course Hardware",
    "section": "",
    "text": "The reTerminal is a development board based on the Raspberry Pi Compute Module 4 (CM4) manufactured by Seeed Studio.\n\n\n\n\n\nThe reTerminal device.\n\n\nNotable features:\n\nCompute Module 4 with 4GB RAM & 32GB eMMC\n5-Inch IPS capacitive multi-touch screen at 1280 x 720 and 293 PPI\nWireless connectivity with dual-band 2.4GHz/5GHz Wi-Fi and Bluetooth 5.0 BLE\nCryptographic co-processor with secure hardware-based key storage\nBuilt-in modules such as accelerometer, light sensor, and RTC\n\n\nSee reTerminal Wiki page for detailed specs and documentation\n\n\n\n\n\n\n\n\nRPI USB-C POWER SUPPLY BLACK US\n\n\nThe reTerminal requires a power supply that can provide a minimum of 3 Amps. The official Raspberry Pi USB-C Power Supply in included in the kit."
  },
  {
    "objectID": "reference/docs/course-hardware.html#compute-module-4",
    "href": "reference/docs/course-hardware.html#compute-module-4",
    "title": "Course Hardware",
    "section": "2 Compute Module 4",
    "text": "2 Compute Module 4\n\n\n\n\n\nRaspberry PI CM 4\n\n\nThe Compute Module 4 (CM4) made by the Raspberry Pi Foundation is powering the reTerminal.\nNotable features:\n\nProcessor: Broadcom BCM2711 quad-core Cortex-A72 (ARM v8) 64-bit SoC @ 1.5GHz\n\n\nSee CM4 datasheet for details.\n\nSee Difference Between ARM64, ARMel, and ARMhf for more info on the different ARM architectures.\n\n2.1 Grove Base Hat for Raspberry Pi\n\n\n\n\n\nGrove Base Hat for GPIO connections\n\n\nIn a typical Raspberry Pi, sensors would be connected via the 40-pin GPIO.\nTo facilitate connections of the Grove sensors, this “Hat” (term for an add-on board of the Raspberry Pi) includes the following types of connection:\n\n6 Digital\n4 Analog\n3 I2C\n1 PWM\n1 UART\n\n\nSee Grove base hat Wiki for details."
  },
  {
    "objectID": "reference/docs/course-hardware.html#sensors",
    "href": "reference/docs/course-hardware.html#sensors",
    "title": "Course Hardware",
    "section": "3 Sensors",
    "text": "3 Sensors\n\n3.1 AHT20 I2C Temperature & Humidity\n\n\n\n\n\nAHT20 I2C temperature/humidity sensor\n\n\nSee AHT20 I2C Industrial Grade Temperature & Humidity Sensor wiki for details.\n\nTemperature measurement range -40 ~ 85°C, Humidity measurement range 0 ~ 100% RH.\nDigital output, Grove I2C interface.\n\n\n\n3.2 AHT20 Libraries\nThe main module for this sensor is provided by Seeed in this Github repository and can be installed with the grove.py library.\nFollow official Step by step installation for python 3 (see below). Don’t use the one-click installation or it will install to the wrong location\ngit clone [https://github.com/Seeed-Studio/grove.py](https://github.com/Seeed-Studio/grove.py)\ncd grove.py\nsudo pip3 install .\nAlternatively, it’s also possible to use Adafruit’s adafruit-circuitpython-ahtx0 library to communicate with the sensor (see library’s Pypi page). However, to instantiate the provided sensor class, you will need to pass it an I2C bus instance. To instantiate an I2C bus instance, install and use the adafruit-extended-bus library (see Pypi page)."
  },
  {
    "objectID": "reference/docs/course-hardware.html#actuators-motors",
    "href": "reference/docs/course-hardware.html#actuators-motors",
    "title": "Course Hardware",
    "section": "4 Actuators & Motors",
    "text": "4 Actuators & Motors\n\n4.1 LED Socket\n\n\n\n\n\nLED\n\n\nLED in a removable socket and potentiometer for power adjustment. LED can be swapped with different colors.\nSee LED wiki page for details.\n\n\n4.2 Cooling Fan\n\n\n\n\n\nCooling Fan\n\n\n5V Cooling Fan 40mm x 10mm with 2-pin JST connector.\n\nSee product page here.\n\n\n\n4.3 Relay\n\n\n\n\n\nRelay switch\n\n\nA digital switch. Controls the on/off flow of electricity with a small digital signal.\n\nOperate voltage: 3.3V-5V\nInput current: 100mA\nRated load: 5A@250VAC 5A@30VDC\n\nSee relay wiki page for details."
  },
  {
    "objectID": "reference/docs/course-hardware.html#cabling",
    "href": "reference/docs/course-hardware.html#cabling",
    "title": "Course Hardware",
    "section": "5 Cabling",
    "text": "5 Cabling\nThe following cables are included in the base kit:\n\nGrove Universal 4 Pin Buckled 5cm Cable.\nGrove Universal 4 Pin Buckled 20cm Cable.\nGrove 4 pin Female Jumper to Grove 4 pin Cable\nGrove 4 pin Male Jumper to Grove 4 pin Cable\n40-pin flat ribbon cable 20cm (female-female).\n2-pin JST SM Plug, one end open."
  },
  {
    "objectID": "reference/docs/python-collections.html",
    "href": "reference/docs/python-collections.html",
    "title": "Python collection types and operations",
    "section": "",
    "text": "Image: https://realpython.com/python-lambda/"
  },
  {
    "objectID": "reference/docs/python-collections.html#overview",
    "href": "reference/docs/python-collections.html#overview",
    "title": "Python collection types and operations",
    "section": "1 Overview",
    "text": "1 Overview\n\nLoops\nList comprehensions\nGenerators\nLambdas\nDictionaries"
  },
  {
    "objectID": "reference/docs/python-collections.html#loops",
    "href": "reference/docs/python-collections.html#loops",
    "title": "Python collection types and operations",
    "section": "2 Loops",
    "text": "2 Loops\nThere are two types of loops in Python, for and while.\n\n2.1 The for loop\nFor loops iterate over a given sequence, or iterator. Here is an example:\n\n\nPython\n\nprimes = [2, 3, 5, 7]\nfor prime in primes:\n    print(prime)\n\nFor loops can iterate over a sequence of numbers using the range function. range returns an iterator object which can be looped using the following syntax:\n\n\nPython\n\n# Prints out the numbers 0,1,2,3,4\nfor x in range(5):\n    print(x)\n\n# Prints out 3,4,5\nfor x in range(3, 6):\n    print(x)\n\n# Prints out 3,5,7\nfor x in range(3, 8, 2):\n    print(x)\n\n\n\n2.2 break and continue statements\nbreak is used to exit a for loop or a while loop, whereas continue is used to skip the current block, and return to the “for” or “while” statement. A few examples:\n\n\nPython\n\n# Prints out only odd numbers - 1,3,5,7,9\nfor x in range(10):\n    # Check if x is even\n    if x % 2 == 0:\n        continue\n    print(x)\n\n# Prints out 0,1,2,3,4\n\ncount = 0\nwhile True:  # we have while loops in Python too.\n    print(count)\n    count += 1\n    if count &gt;= 5:\n        break"
  },
  {
    "objectID": "reference/docs/python-collections.html#list-comprehensions",
    "href": "reference/docs/python-collections.html#list-comprehensions",
    "title": "Python collection types and operations",
    "section": "3 List Comprehensions",
    "text": "3 List Comprehensions\nList Comprehensions is a very powerful tool, which creates a new list based on another list, in a single, readable line.\nFor example, let’s say we need to create a list of integers which specify the length of each word in a certain sentence, but only if the word is not the word “the”.\n\n\nPython\n\nsentence = \"the quick brown fox jumps over the lazy dog\"\nwords = sentence.split()\nword_lengths = []\nfor word in words:\n    if word != \"the\":\n        word_lengths.append(len(word))\nprint(words)\nprint(word_lengths)\n\nUsing a list comprehension, we could simplify this process to this notation:\n\n\nPython\n\nsentence = \"the quick brown fox jumps over the lazy dog\"\nwords = sentence.split()\nword_lengths = [len(word) for word in words if word != \"the\"]\nprint(words)\nprint(word_lengths)"
  },
  {
    "objectID": "reference/docs/python-collections.html#generators",
    "href": "reference/docs/python-collections.html#generators",
    "title": "Python collection types and operations",
    "section": "4 Generators",
    "text": "4 Generators\nGenerators are very easy to implement, but a bit difficult to understand.\nGenerators are used to create iterators, but with a different approach. Generators are simple functions which return an iterable set of items, one at a time, in a special way.\nWhen an iteration over a set of item starts using the for statement, the generator is run. Once the generator’s function code reaches a “yield” statement, the generator yields its execution back to the for loop, returning a new value from the set. The generator function can generate as many values (possibly infinite) as it wants, yielding each one in its turn.\nHere is a simple example of a generator function which returns 7 random integers:\n\n\nPython\n\nimport random\n\n\ndef lottery():\n    # returns 6 numbers between 1 and 40\n    for i in range(6):\n        yield random.randint(1, 40)\n\n    # returns a 7th number between 1 and 15\n    yield random.randint(1, 15)\n\n\nfor random_number in lottery():\n    print(\"And the next number is... %d!\" % (random_number))\n\nThis function decides how to generate the random numbers on its own, and executes the yield statements one at a time, pausing in between to yield execution back to the main for loop."
  },
  {
    "objectID": "reference/docs/python-collections.html#lambda-functions",
    "href": "reference/docs/python-collections.html#lambda-functions",
    "title": "Python collection types and operations",
    "section": "5 Lambda functions",
    "text": "5 Lambda functions\nNormally we define a function using the def keyword somewhere in the code and call it whenever we need to use it.\n\n\nPython\n\ndef sum(a, b):\n    return a + b\n\n\na = 1\nb = 2\nc = sum(a, b)\nprint(c)\n\nNow instead of defining the function somewhere and calling it, we can use python’s lambda functions, which are inline functions defined at the same place we use it. So we don’t need to declare a function somewhere and revisit the code just for a single time use.\nThey don’t need to have a name, so they also called anonymous functions. We define a lambda function using the keyword lambda.\n\n\nPython\n\nyour_function_name = lambda inputs: output\n\nSo the above sum example using lambda function would be,\n\n\nPython\n\na = 1\nb = 2\nsum = lambda x, y: x + y\nc = sum(a, b)\nprint(c)\n\nHere we are assigning the lambda function to the variable sum, and upon giving the arguments i.e. a and b, it works like a normal function."
  },
  {
    "objectID": "reference/docs/python-collections.html#dictionaries",
    "href": "reference/docs/python-collections.html#dictionaries",
    "title": "Python collection types and operations",
    "section": "6 Dictionaries",
    "text": "6 Dictionaries\n\nA dictionary is a data type similar to arrays, but works with keys and values instead of indexes. Each value stored in a dictionary can be accessed using a key, which is any type of object (a string, a number, a list, etc.) instead of using its index to address it.\nFor example, a database of phone numbers could be stored using a dictionary like this:\n\n\nPython\n\nphonebook = {}\nphonebook[\"John\"] = 938477566\nphonebook[\"Jack\"] = 938377264\nphonebook[\"Jill\"] = 947662781\nprint(phonebook)\n\nAlternatively, a dictionary can be initialized with the same values in the following notation:\n\n\nPython\n\nphonebook = {\"John\": 938477566, \"Jack\": 938377264, \"Jill\": 947662781}\nprint(phonebook)\n\n\n6.1 Iterating over dictionaries\nDictionaries can be iterated over, just like a list. However, a dictionary, unlike a list, does not keep the order of the values stored in it. To iterate over key value pairs, use the following syntax:\n\n\nPython\n\nphonebook = {\"John\": 938477566, \"Jack\": 938377264, \"Jill\": 947662781}\nfor name, number in phonebook.items():\n    print(\"Phone number of %s is %d\" % (name, number))\n\n\n\n6.2 Removing a value\nTo remove a specified index, use either one of the following notations:\n\n\nPython\n\nphonebook = {\"John\": 938477566, \"Jack\": 938377264, \"Jill\": 947662781}\ndel phonebook[\"John\"]\nprint(phonebook)\n\nor:\n\n\nPython\n\nphonebook = {\"John\": 938477566, \"Jack\": 938377264, \"Jill\": 947662781}\nphonebook.pop(\"John\")\nprint(phonebook)"
  },
  {
    "objectID": "reference/docs/bash-commands.html",
    "href": "reference/docs/bash-commands.html",
    "title": "Bash commands",
    "section": "",
    "text": "Image: https://www.svgrepo.com/svg/353475/bash"
  },
  {
    "objectID": "reference/docs/bash-commands.html#tips-tricks",
    "href": "reference/docs/bash-commands.html#tips-tricks",
    "title": "Bash commands",
    "section": "1 Tips & tricks",
    "text": "1 Tips & tricks\n\n1.1 man & --help\n\n\n1.2 Keyboard shortcuts\n\n\n1.3 Configuration"
  },
  {
    "objectID": "reference/docs/bash-commands.html#common-commands",
    "href": "reference/docs/bash-commands.html#common-commands",
    "title": "Bash commands",
    "section": "2 Common commands",
    "text": "2 Common commands\n\n2.1 cd\n\n\n2.2 cat\n\n\n2.3 file\n\n\n2.4 find\n\n\n2.5 grep\n\n\n2.6 du\n\n\n2.7 ssh"
  },
  {
    "objectID": "about/index.html",
    "href": "about/index.html",
    "title": "About",
    "section": "",
    "text": "About this website\n\n\nDescription of technologies and resources used to build this website. Acknowledgements, copyright, terms of use, etc. can be found on this page.\n\n\n\n\n\n1/27/25, 1:38:35 PM\n\n\n\n\n\n\n\n\n\n\n\n\nCalendar\n\n\nRoadmap for course deliverables; record of lectures & activites we have covered along the way. \n\n\n\n\n\n1/27/25, 1:38:35 PM\n\n\n\n\n\n\n\n\n\n\n\n\nSyllabus\n\n\nCourse description outlining goals, expectations, resources, and other important information. \n\n\n\n\n\n1/27/25, 1:38:35 PM\n\n\n\n\n\n\nNo matching items\n\n Back to topReuseCC BY-NC 4.0. ©2022-25 Mauricio Buschinelli & Michael Haaf.\n(View License)"
  },
  {
    "objectID": "about/this-site.html",
    "href": "about/this-site.html",
    "title": "About this website",
    "section": "",
    "text": "Course content, both for lectures and assignments, has been adapted by me from a variety of sources. This section serves the purpose of both acknowledging these references as well as pointing the way for curious students to begin investigating further into course material than we had time to cover.\n\n\nAll course content was either written by Mauricio Buschinelli, Michael Haaf, or explicitly adapted from external resources with attributions made clear. This course content retains the licenses of the original works where relevant, and is otherwise licensed under the Creative Commons Attribution 4.0 International License.\n\nTerms of use\nYou are free to:\n\nShare: copy and redistribute the material in any medium or format\nAdapt: remix, transform, and build upon the material for any purpose, even commercially.\n\nUnder the following terms:\n\nAttribution: You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.\n\nCreative Commons Attribution 4.0 International License"
  },
  {
    "objectID": "about/this-site.html#course-content",
    "href": "about/this-site.html#course-content",
    "title": "About this website",
    "section": "",
    "text": "Course content, both for lectures and assignments, has been adapted by me from a variety of sources. This section serves the purpose of both acknowledging these references as well as pointing the way for curious students to begin investigating further into course material than we had time to cover.\n\n\nAll course content was either written by Mauricio Buschinelli, Michael Haaf, or explicitly adapted from external resources with attributions made clear. This course content retains the licenses of the original works where relevant, and is otherwise licensed under the Creative Commons Attribution 4.0 International License.\n\nTerms of use\nYou are free to:\n\nShare: copy and redistribute the material in any medium or format\nAdapt: remix, transform, and build upon the material for any purpose, even commercially.\n\nUnder the following terms:\n\nAttribution: You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.\n\nCreative Commons Attribution 4.0 International License"
  },
  {
    "objectID": "about/this-site.html#course-website",
    "href": "about/this-site.html#course-website",
    "title": "About this website",
    "section": "2 Course website",
    "text": "2 Course website\nDetails about how this website was built follow.\n\n2.1 Colophon\n\n\n\n\n\nFrom Wikipedia: In publishing, a colophon is a brief statement containing information about the publication of a book… Some web pages also have colophons, which frequently contain (X)HTML, CSS, or usability standards compliance information and links to website validation tests.\n\n\n\nMarkup: Markdown\nFramework: Quarto\nDeployment: GitHub Pages\n\nYou can follow along directly with course updates at the course repository."
  },
  {
    "objectID": "about/calendar.html",
    "href": "about/calendar.html",
    "title": "Calendar",
    "section": "",
    "text": "This is the authoritative calendar for content covered in class, and for content you should expect to see covered as we continue through the course.\nYou can compare this calendar with the calendar from the Course Outline to see where this course has deviated from the original outline."
  },
  {
    "objectID": "about/calendar.html#january",
    "href": "about/calendar.html#january",
    "title": "Calendar",
    "section": "1 January",
    "text": "1 January\n\n1.1 Deliverables\n\nLab 0: Due January 31\n\n\n\n1.2 Schedule\n\nJan 20: Introduction to course\nJan 24: Setting up our developer environment\nJan 27: Review bash, begin Lab 0"
  },
  {
    "objectID": "about/calendar.html#february",
    "href": "about/calendar.html#february",
    "title": "Calendar",
    "section": "2 February",
    "text": "2 February\n\n2.1 Deliverables\n\n\n2.2 Schedule"
  },
  {
    "objectID": "about/calendar.html#march",
    "href": "about/calendar.html#march",
    "title": "Calendar",
    "section": "3 March",
    "text": "3 March\n\n3.1 Deliverables\n\n\n3.2 Schedule"
  },
  {
    "objectID": "about/calendar.html#april",
    "href": "about/calendar.html#april",
    "title": "Calendar",
    "section": "4 April",
    "text": "4 April\n\n4.1 Deliverables\n\n\n4.2 Schedule"
  },
  {
    "objectID": "about/calendar.html#may",
    "href": "about/calendar.html#may",
    "title": "Calendar",
    "section": "5 May",
    "text": "5 May\n\n5.1 Deliverables\n\n\n5.2 Schedule"
  },
  {
    "objectID": "about/syllabus.html",
    "href": "about/syllabus.html",
    "title": "Syllabus",
    "section": "",
    "text": "Room, times, etc.: see Course Outline\nOffice: Penfield 311\nOffice hours: Mon/Fri 11:00 - 12:30pm or so\nEmail: michael DOT haaf AT johnabbott DOT qc DOT ca\nCourse webpage: This website for all content, Moodle for assignment/project/quiz submissions.\n\n\n\n\n\n\nForgive me the smarmy comic, this is usually true…\n\n\n\n\n\nTeams - For communicating (fastest, most reliable that I will check it same-day)\nMIO - For communicating (non-time-critical)\nEmail - For communicating (time-critical). Will aim for &lt;24hr response.\nMoodle - For receiving & submitting exercises/assignments/project and getting marks\n\n\n\n\n\n45% Assignments and Labs\n20% Test (first week of April)\n35% Project Milestones"
  },
  {
    "objectID": "about/syllabus.html#logistics",
    "href": "about/syllabus.html#logistics",
    "title": "Syllabus",
    "section": "",
    "text": "Room, times, etc.: see Course Outline\nOffice: Penfield 311\nOffice hours: Mon/Fri 11:00 - 12:30pm or so\nEmail: michael DOT haaf AT johnabbott DOT qc DOT ca\nCourse webpage: This website for all content, Moodle for assignment/project/quiz submissions.\n\n\n\n\n\n\nForgive me the smarmy comic, this is usually true…\n\n\n\n\n\nTeams - For communicating (fastest, most reliable that I will check it same-day)\nMIO - For communicating (non-time-critical)\nEmail - For communicating (time-critical). Will aim for &lt;24hr response.\nMoodle - For receiving & submitting exercises/assignments/project and getting marks\n\n\n\n\n\n45% Assignments and Labs\n20% Test (first week of April)\n35% Project Milestones"
  },
  {
    "objectID": "about/syllabus.html#course-material",
    "href": "about/syllabus.html#course-material",
    "title": "Syllabus",
    "section": "2 Course material",
    "text": "2 Course material\nThere are no required textbooks for this course – this website will contain all of the content that you need to complete course deliverables. Additionally, each lecture will contain references to additional resources for exploring each topic in further detail beyond the scope of the course."
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Reference",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Modified - Oldest\n        \n         \n          Modified - Newest\n        \n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nCourse software\n\n\nThe essential software that will be used for development during the course.\n\n\n\n\n\n2025-01-20\n\n\n2 min\n\n\n2025-01-27\n\n\n\n\n\n\n\n\n\n\n\n\nCourse Hardware\n\n\nList of hardware available for the course as well as their respective specifications and documentation.\n\n\n\n\n\n2025-01-20\n\n\n3 min\n\n\n2025-01-27\n\n\n\n\n\n\n\n\n\n\n\n\nBash commands\n\n\nUseful bash commands\n\n\n\n\n\n2025-01-24\n\n\n1 min\n\n\n2025-01-27\n\n\n\n\n\n\n\n\n\n\n\n\nOOP in Python\n\n\nHow to use object oriented programming techniques in Python.\n\n\n\n\n\n2025-01-24\n\n\n22 min\n\n\n2025-01-27\n\n\n\n\n\n\n\n\n\n\n\n\nPython collection types and operations\n\n\nUseful python collection types and operations\n\n\n\n\n\n2025-01-24\n\n\n5 min\n\n\n2025-01-27\n\n\n\n\n\n\nNo matching items\n\n Back to topReuseCC BY-NC 4.0. ©2022-25 Mauricio Buschinelli & Michael Haaf.\n(View License)"
  },
  {
    "objectID": "reference/docs/python-oop.html",
    "href": "reference/docs/python-oop.html",
    "title": "OOP in Python",
    "section": "",
    "text": "Image: https://realpython.com/courses/object-oriented-programming-exercises/"
  },
  {
    "objectID": "reference/docs/python-oop.html#overview",
    "href": "reference/docs/python-oop.html#overview",
    "title": "OOP in Python",
    "section": "1 Overview",
    "text": "1 Overview\nObject-oriented programming (OOP) in Python helps you structure your code by grouping related data and behaviors into objects. You start by defining classes, which act as blueprints, and then create objects from them. OOP simplifies modeling real-world concepts in your programs and enables you to build systems that are more reusable and scalable.\nBy the end of this tutorial, you’ll understand that:\n\nObject-oriented programming in Python involves creating classes as blueprints for objects. These objects contain data and the methods needed to manipulate that data.\nThe four key concepts of OOP in Python are encapsulation, inheritance, abstraction, and polymorphism.\nYou create an object in Python by instantiating a class, which involves calling the class name followed by parentheses.\nClass inheritance in Python allows a class to inherit attributes and methods from another class, known as the parent class.\nYou use super() in Python to call a method from the parent class, allowing you to extend or modify inherited behavior.\n\nYou’ll explore how to define classes, instantiate classes to create objects, and leverage inheritance to build robust systems in Python.\nNote: This tutorial is adapted from the chapter “Object-Oriented Programming (OOP)” in Python Basics: A Practical Introduction to Python 3."
  },
  {
    "objectID": "reference/docs/python-oop.html#what-is-object-oriented-programming-in-python",
    "href": "reference/docs/python-oop.html#what-is-object-oriented-programming-in-python",
    "title": "OOP in Python",
    "section": "2 What Is Object-Oriented Programming in Python?",
    "text": "2 What Is Object-Oriented Programming in Python?\nObject-oriented programming is a programming paradigm that provides a means of structuring programs so that properties and behaviors are bundled into individual objects.\nFor example, an object could represent a person with properties like a name, age, and address and behaviors such as walking, talking, breathing, and running. Or it could represent an email with properties like a recipient list, subject, and body and behaviors like adding attachments and sending.\nPut another way, object-oriented programming is an approach for modeling concrete, real-world things, like cars, as well as relations between things, like companies and employees or students and teachers. OOP models real-world entities as software objects that have some data associated with them and can perform certain operations.\nOOP also exists in other programming languages and is often described to center around the four pillars, or four tenants of OOP:\n\n2.1 Encapsulation\nEncapsulation allows you to bundle data (attributes) and behaviors (methods) within a class to create a cohesive unit. By defining methods to control access to attributes and its modification, encapsulation helps maintain data integrity and promotes modular, secure code.\n\n\n2.2 Inheritance\nInheritance enables the creation of hierarchical relationships between classes, allowing a subclass to inherit attributes and methods from a parent class. This promotes code reuse and reduces duplication.\n\n\n2.3 Abstraction\nAbstraction focuses on hiding implementation details and exposing only the essential functionality of an object. By enforcing a consistent interface, abstraction simplifies interactions with objects, allowing developers to focus on what an object does rather than how it achieves its functionality.\n\n\n2.4 Polymorphism\nPolymorphism allows you to treat objects of different types as instances of the same base type, as long as they implement a common interface or behavior. Python’s duck typing make it especially suited for polymorphism, as it allows you to access attributes and methods on objects without needing to worry about their actual class."
  },
  {
    "objectID": "reference/docs/python-oop.html#how-do-you-define-a-class-in-python",
    "href": "reference/docs/python-oop.html#how-do-you-define-a-class-in-python",
    "title": "OOP in Python",
    "section": "3 How Do You Define a Class in Python?",
    "text": "3 How Do You Define a Class in Python?\nIn Python, you define a class by using the class keyword followed by a name and a colon. Then you use .__init__() to declare which attributes each instance of the class should have:\n\n\nPython\n\nclass Worker:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\nBut what does all of that mean? And why do you even need classes in the first place? Take a step back and consider using built-in, primitive data structures as an alternative.\nPrimitive data structures—like numbers, strings, and lists—are designed to represent straightforward pieces of information, such as the cost of an apple, the name of a poem, or your favorite colors, respectively. What if you want to represent something more complex?\nFor example, you might want to track employees in an organization. You need to store some basic information about each employee, such as their name, age, position, and the year they started working.\nOne way to do this is to represent each worker as a list:\n\n\nPython\n\nkirk = [\"James Kirk\", 34, \"Captain\", 2265]\nspock = [\"Spock\", 35, \"Science Officer\", 2254]\nmccoy = [\"Leonard McCoy\", \"Chief Medical Officer\", 2266]\n\nThere are a number of issues with this approach.\nFirst, it can make larger code files more difficult to manage. If you reference kirk[0] several lines away from where you declared the kirk list, will you remember that the element with index 0 is the employee’s name?\nSecond, it can introduce errors if employees don’t have the same number of elements in their respective lists. In the mccoy list above, the age is missing, so mccoy[1] will return \"Chief Medical Officer\" instead of Dr. McCoy’s age.\nA great way to make this type of code more manageable and more maintainable is to use classes.\n\n3.1 Classes vs Instances\nClasses allow you to create user-defined data structures. Classes define functions called methods, which identify the behaviors and actions that an object created from the class can perform with its data.\nIn this tutorial, you’ll create a Dog class that stores some information about the characteristics and behaviors that an individual dog can have.\nA class is a blueprint for how to define something. It doesn’t actually contain any data. The Dog class specifies that a name and an age are necessary for defining a dog, but it doesn’t contain the name or age of any specific dog.\nWhile the class is the blueprint, an instance is an object that’s built from a class and contains real data. An instance of the Dog class is not a blueprint anymore. It’s an actual dog with a name, like Miles, who’s four years old.\nPut another way, a class is like a form or questionnaire. An instance is like a form that you’ve filled out with information. Just like many people can fill out the same form with their own unique information, you can create many instances from a single class.\n\n\n3.2 Class Definition\nYou start all class definitions with the class keyword, then add the name of the class and a colon. Python will consider any code that you indent below the class definition as part of the class’s body.\nHere’s an example of a Dog class:\n\n\nPython\n\nclass Dog:\n    pass\n\nThe body of the Dog class consists of a single statement: the pass keyword. Python programmers often use pass as a placeholder indicating where code will eventually go. It allows you to run this code without Python throwing an error.\n\nNote: Python class names are written in CapitalizedWords notation by convention. For example, a class for a specific breed of dog, like the Jack Russell Terrier, would be written as JackRussellTerrier.\n\nThe Dog class isn’t very interesting right now, so you’ll spruce it up a bit by defining some properties that all Dog objects should have. There are several properties that you can choose from, including name, age, coat color, and breed. To keep the example small in scope, you’ll just use name and age.\nYou define the properties that all Dog objects must have in a method called .__init__(). Every time you create a new Dog object, .__init__() sets the initial state of the object by assigning the values of the object’s properties. That is, .__init__() initializes each new instance of the class.\nYou can give .__init__() any number of parameters, but the first parameter will always be a variable called self. When you create a new class instance, then Python automatically passes the instance to the self parameter in .__init__() so that Python can define the new attributes on the object.\nUpdate the Dog class with an .__init__() method that creates .name and .age attributes:\n\n\nPython\n\nclass Dog:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\nMake sure that you indent the .__init__() method’s signature by four spaces, and the body of the method by eight spaces. This indentation is vitally important. It tells Python that the .__init__() method belongs to the Dog class.\nIn the body of .__init__(), there are two statements using the self variable:\n\nself.name = name creates an attribute called name and assigns the value of the name parameter to it.\nself.age = age creates an attribute called age and assigns the value of the age parameter to it.\n\nAttributes created in .__init__() are called instance attributes. An instance attribute’s value is specific to a particular instance of the class. All Dog objects have a name and an age, but the values for the name and age attributes will vary depending on the Dog instance.\nOn the other hand, class attributes are attributes that have the same value for all class instances. You can define a class attribute by assigning a value to a variable name outside of .__init__().\nFor example, the following Dog class has a class attribute called species with the value \"Canis familiaris\":\n\n\nPython\n\nclass Dog:\n    species = \"Canis familiaris\"\n\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\nYou define class attributes directly beneath the first line of the class name and indent them by four spaces. You always need to assign them an initial value. When you create an instance of the class, then Python automatically creates and assigns class attributes to their initial values.\nUse class attributes to define properties that should have the same value for every class instance. Use instance attributes for properties that vary from one instance to another.\nNow that you have a Dog class, it’s time to create some dogs!"
  },
  {
    "objectID": "reference/docs/python-oop.html#how-do-you-instantiate-a-class-in-python",
    "href": "reference/docs/python-oop.html#how-do-you-instantiate-a-class-in-python",
    "title": "OOP in Python",
    "section": "4 How Do You Instantiate a Class in Python?",
    "text": "4 How Do You Instantiate a Class in Python?\nCreating a new object from a class is called instantiating a class. You can create a new object by typing the name of the class, followed by opening and closing parentheses:\nbash {filename=Python Interpreter} &gt;&gt;&gt; class Dog: ...     pass ... &gt;&gt;&gt; Dog() &lt;__main__.Dog object at 0x106702d30&gt;\nYou first create a new Dog class with no attributes or methods, and then you instantiate the Dog class to create a Dog object.\nIn the output above, you can see that you now have a new Dog object at 0x106702d30. This funny-looking string of letters and numbers is a memory address that indicates where Python stores the Dog object in your computer’s memory. Note that the address on your screen will be different.\nNow instantiate the Dog class a second time to create another Dog object:\nbash {filename=Python Interpreter} &gt;&gt;&gt; Dog() &lt;__main__.Dog object at 0x0004ccc90&gt;\nThe new Dog instance is located at a different memory address. That’s because it’s an entirely new instance and is completely unique from the first Dog object that you created.\nbash {filename=Python Interpreter} &gt;&gt;&gt; a = Dog() &gt;&gt;&gt; b = Dog() &gt;&gt;&gt; a == b False\nIn this code, you create two new Dog objects and assign them to the variables a and b. When you compare a and b using the == operator, the result is False. Even though a and b are both instances of the Dog class, they represent two distinct objects in memory.\n\n4.1 Class and Instance Attributes\nNow create a new Dog class with a class attribute called .species and two instance attributes called .name and .age:\nbash {filename=Python Interpreter}     &gt;&gt;&gt; class Dog:     ...     species = \"Canis familiaris\"     ...     def __init__(self, name, age):     ...         self.name = name     ...         self.age = age     ...\nTo instantiate this Dog class, you need to provide values for name and age. If you don’t, then Python raises a TypeError:\nbash {filename=Python Interpreter} &gt;&gt;&gt; Dog() Traceback (most recent call last):   ... TypeError: __init__() missing 2 required positional arguments: 'name' and 'age'\nTo pass arguments to the name and age parameters, put values into the parentheses after the class name:\nbash {filename=Python Interpreter} &gt;&gt;&gt; miles = Dog(\"Miles\", 4) &gt;&gt;&gt; buddy = Dog(\"Buddy\", 9)\nThis creates two new Dog instances—one for a four-year-old dog named Miles and one for a nine-year-old dog named Buddy.\nThe Dog class’s .__init__() method has three parameters, so why are you only passing two arguments to it in the example?\nWhen you instantiate the Dog class, Python creates a new instance of Dog and passes it to the first parameter of .__init__(). This essentially removes the self parameter, so you only need to worry about the name and age parameters.\nNote: Behind the scenes, Python both creates and initializes a new object when you use this syntax. If you want to dive deeper, then you can read the dedicated tutorial about the Python class constructor.\nAfter you create the Dog instances, you can access their instance attributes using dot notation:\n```bash {filename=Python Interpreter} &gt;&gt;&gt; miles.name ‘Miles’ &gt;&gt;&gt; miles.age 4\n\n\n\nbuddy.name ‘Buddy’ buddy.age 9\n\n\n\n\nYou can access class attributes the same way:\n\n```bash {filename=Python Interpreter}\n&gt;&gt;&gt; buddy.species\n'Canis familiaris'\nOne of the biggest advantages of using classes to organize data is that instances are guaranteed to have the attributes you expect. All Dog instances have .species, .name, and .age attributes, so you can use those attributes with confidence, knowing that they’ll always return a value.\nAlthough the attributes are guaranteed to exist, their values can change dynamically:\n```bash {filename=Python Interpreter} &gt;&gt;&gt; buddy.age = 10 &gt;&gt;&gt; buddy.age 10\n\n\n\nmiles.species = “Felis silvestris” miles.species ‘Felis silvestris’\n\n\n\n\nIn this example, you change the `.age` attribute of the `buddy` object to `10`. Then you\nchange the `.species` attribute of the `miles` object to `\"Felis silvestris\"`, which is a\nspecies of cat. That makes Miles a pretty strange dog, but it's valid Python!\n\nThe key takeaway here is that custom objects are mutable by default. An object is mutable\nif you can alter it dynamically. For example, lists and\n[dictionaries](https://realpython.com/python-dicts/) are mutable, but strings and tuples\nare [immutable](https://realpython.com/python-mutable-vs-immutable-types/).\n\n### Instance Methods\n\n**Instance methods** are functions that you define inside a class and can only call on an\ninstance of that class. Just like `.__init__()`, an instance method always takes `self` as\nits first parameter.\n\nOpen a new editor window in IDLE and type in the following `Dog` class:\n\n```python {filename=Python}\nclass Dog:\n    species = \"Canis familiaris\"\n\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    # Instance method\n    def description(self):\n        return f\"{self.name} is {self.age} years old\"\n\n    # Another instance method\n    def speak(self, sound):\n        return f\"{self.name} says {sound}\"\nThis Dog class has two instance methods:\n\n.description() returns a string displaying the name and age of the dog.\n.speak() has one parameter called sound and returns a string containing the dog’s name and the sound that the dog makes.\n\n```bash {filename=Python Interpreter} &gt;&gt;&gt; miles = Dog(“Miles”, 4)\n\n\n\nmiles.description() ‘Miles is 4 years old’\n\n\n\n\n\n\nmiles.speak(“Woof Woof”) ‘Miles says Woof Woof’\n\n\n\n\n\n\nmiles.speak(“Bow Wow”) ‘Miles says Bow Wow’\n\n\n\n\nIn the above `Dog` class, `.description()` returns a string containing information about\nthe `Dog` instance `miles`. When writing your own classes, it's a good idea to have a\nmethod that returns a string containing useful information about an instance of the class.\nHowever, `.description()` isn't the most\n[Pythonic](https://realpython.com/learning-paths/writing-pythonic-code/) way of doing\nthis.\n\nWhen you create a `list` object, you can use `print()` to display a string that looks like\nthe list:\n\n```bash {filename=Python Interpreter}\n&gt;&gt;&gt; names = [\"Miles\", \"Buddy\", \"Jack\"]\n&gt;&gt;&gt; print(names)\n['Miles', 'Buddy', 'Jack']\nGo ahead and print the miles object to see what output you get:\nbash {filename=Python Interpreter} &gt;&gt;&gt; print(miles) &lt;__main__.Dog object at 0x00aeff70&gt;\nWhen you print miles, you get a cryptic-looking message telling you that miles is a Dog object at the memory address 0x00aeff70. This message isn’t very helpful. You can change what gets printed by defining a special instance method called .__str__().\nIn the editor window, change the name of the Dog class’s .description() method to .__str__():\n\n\nPython\n\nclass Dog:\n    # ...\n\n    def __str__(self):\n        return f\"{self.name} is {self.age} years old\"\n\nMethods like .__init__() and .__str__() are called dunder methods because they begin and end with double underscores. There are many dunder methods that you can use to customize classes in Python. Understanding dunder methods is an important part of mastering object-oriented programming in Python, but for your first exploration of the topic, you’ll stick with these two dunder methods.\nNote: Check out When Should You Use .__repr__() vs .__str__() in Python? to learn more about .__str__() and its cousin .__repr__()."
  },
  {
    "objectID": "reference/docs/python-oop.html#how-do-you-inherit-from-another-class-in-python",
    "href": "reference/docs/python-oop.html#how-do-you-inherit-from-another-class-in-python",
    "title": "OOP in Python",
    "section": "5 How Do You Inherit From Another Class in Python?",
    "text": "5 How Do You Inherit From Another Class in Python?\nInheritance is the process by which one class takes on the attributes and methods of another. Newly formed classes are called child classes, and the classes that you derive child classes from are called parent classes.\nYou inherit from a parent class by creating a new class and putting the name of the parent class into parentheses:\n\n\nPython\n\nclass Parent:\n    hair_color = \"brown\"\n\n\nclass Child(Parent):\n    pass\n\nIn this minimal example, the child class Child inherits from the parent class Parent. Because child classes take on the attributes and methods of parent classes, Child.hair_color is also \"brown\" without your explicitly defining that.\nNote: This tutorial is adapted from the chapter “Object-Oriented Programming (OOP)” in Python Basics: A Practical Introduction to Python 3. If you enjoy what you’re reading, then be sure to check out the rest of the book and the learning path.\nYou can also check out the Python Basics: Building Systems With Classes video course to reinforce the skills that you’ll develop in this section of the tutorial.\nChild classes can override or extend the attributes and methods of parent classes. In other words, child classes inherit all of the parent’s attributes and methods but can also specify attributes and methods that are unique to themselves.\nAlthough the analogy isn’t perfect, you can think of object inheritance sort of like genetic inheritance.\nYou may have inherited your hair color from your parents. It’s an attribute that you were born with. But maybe you decide to color your hair purple. Assuming that your parents don’t have purple hair, you’ve just overridden the hair color attribute that you inherited from your parents:\n\n\nPython\n\nclass Parent:\n    hair_color = \"brown\"\n\n\nclass Child(Parent):\n    hair_color = \"purple\"\n\nIf you change the code example like this, then Child.hair_color will be \"purple\".\nYou also inherit, in a sense, your language from your parents. If your parents speak English, then you’ll also speak English. Now imagine you decide to learn a second language, like German. In this case, you’ve extended your attributes because you’ve added an attribute that your parents don’t have:\n\n\nPython\n\nclass Parent:\n    speaks = [\"English\"]\n\n\nclass Child(Parent):\n    def __init__(self):\n        super().__init__()\n        self.speaks.append(\"German\")\n\nYou’ll learn more about how the code above works in the sections below. But before you dive deeper into inheritance in Python, you’ll take a walk to a dog park to better understand why you might want to use inheritance in your own code.\n\n5.1 Example: Dog Park\nPretend for a moment that you’re at a dog park. There are many dogs of different breeds at the park, all engaging in various dog behaviors.\nSuppose now that you want to model the dog park with Python classes. The Dog class that you wrote in the previous section can distinguish dogs by name and age but not by breed.\nYou could modify the Dog class in the editor window by adding a .breed attribute:\n\n\nPython\n\nclass Dog:\n    species = \"Canis familiaris\"\n\n    def __init__(self, name, age, breed):\n        self.name = name\n        self.age = age\n        self.breed = breed\n\n    def __str__(self):\n        return f\"{self.name} is {self.age} years old\"\n\n    def speak(self, sound):\n        return f\"{self.name} says {sound}\"\n\nbash {filename=Python interpreter} &gt;&gt;&gt; miles = Dog(\"Miles\", 4, \"Jack Russell Terrier\") &gt;&gt;&gt; buddy = Dog(\"Buddy\", 9, \"Dachshund\") &gt;&gt;&gt; jack = Dog(\"Jack\", 3, \"Bulldog\") &gt;&gt;&gt; jim = Dog(\"Jim\", 5, \"Bulldog\")\nEach breed of dog has slightly different behaviors. For example, bulldogs have a low bark that sounds like woof, but dachshunds have a higher-pitched bark that sounds more like yap.\nUsing just the Dog class, you must supply a string for the sound argument of .speak() every time you call it on a Dog instance:\n```bash {filename=Python Interpreter} &gt;&gt;&gt; buddy.speak(“Yap”) ‘Buddy says Yap’\n\n\n\njim.speak(“Woof”) ‘Jim says Woof’\n\n\n\n\n\n\njack.speak(“Woof”) ‘Jack says Woof’\n\n\n\n\nPassing a string to every call to `.speak()` is repetitive and inconvenient. Moreover, the\n`.breed` attribute should determine the string representing the sound that each `Dog`\ninstance makes, but here you have to manually pass the correct string to `.speak()` every\ntime you call it.\n\nYou can simplify the experience of working with the `Dog` class by creating a child class\nfor each breed of dog. This allows you to extend the functionality that each child class\ninherits, including specifying a default argument for `.speak()`.\n\n(/account/join/){.small .text-muted rel=\"nofollow\"}\n\n### Parent Classes vs Child Classes\n\nIn this section, you'll create a child class for each of the three breeds mentioned above:\nJack Russell terrier, dachshund, and bulldog.\n\nFor reference, here's the full definition of the `Dog` class that you're currently working\nwith:\n\n```python {filename=Python}\nclass Dog:\n    species = \"Canis familiaris\"\n\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def __str__(self):\n        return f\"{self.name} is {self.age} years old\"\n\n    def speak(self, sound):\n        return f\"{self.name} says {sound}\"\nAfter doing the dog park example in the previous section, you’ve removed .breed again. You’ll now write code to keep track of a dog’s breed using child classes instead.\nTo create a child class, you create a new class with its own name and then put the name of the parent class in parentheses. Add the following to the dog.py file to create three new child classes of the Dog class:\n\n\nPython\n\n# ...\n\n\nclass JackRussellTerrier(Dog):\n    pass\n\n\nclass Dachshund(Dog):\n    pass\n\n\nclass Bulldog(Dog):\n    pass\n\nbash {filename=Python Interpreter} &gt;&gt;&gt; miles = JackRussellTerrier(\"Miles\", 4) &gt;&gt;&gt; buddy = Dachshund(\"Buddy\", 9) &gt;&gt;&gt; jack = Bulldog(\"Jack\", 3) &gt;&gt;&gt; jim = Bulldog(\"Jim\", 5)\nInstances of child classes inherit all of the attributes and methods of the parent class:\n```bash {filename=Python Interpreter} &gt;&gt;&gt; miles.species ‘Canis familiaris’\n\n\n\nbuddy.name ‘Buddy’\n\n\n\n\n\n\nprint(jack) Jack is 3 years old\n\n\n\n\n\n\njim.speak(“Woof”) ‘Jim says Woof’\n\n\n\n\nTo determine which class a given object belongs to, you can use the built-in `type()`:\n\n```bash {filename=Python Interpreter}\n&gt;&gt;&gt; type(miles)\n&lt;class '__main__.JackRussellTerrier'&gt;\nWhat if you want to determine if miles is also an instance of the Dog class? You can do this with the built-in isinstance():\nbash {filename=Python Interpreter} &gt;&gt;&gt; isinstance(miles, Dog) True\nNotice that isinstance() takes two arguments, an object and a class. In the example above, isinstance() checks if miles is an instance of the Dog class and returns True.\nThe miles, buddy, jack, and jim objects are all Dog instances, but miles isn’t a Bulldog instance, and jack isn’t a Dachshund instance:\n```bash {filename=Python Interpreter} &gt;&gt;&gt; isinstance(miles, Bulldog) False\n\n\n\nisinstance(jack, Dachshund) False\n\n\n\n\nMore generally, all objects created from a child class are instances of the parent class,\nalthough they may not be instances of other child classes.\n\nNow that you've created child classes for some different breeds of dogs, you can give each\nbreed its own sound.\n\n### Parent Class Functionality Extension\n\nSince different breeds of dogs have slightly different barks, you want to provide a\ndefault value for the `sound` argument of their respective `.speak()` methods. To do this,\nyou need to override `.speak()` in the class definition for each breed.\n\nTo override a method defined on the parent class, you define a method with the same name\non the child class. Here's what that looks like for the `JackRussellTerrier` class:\n\n```python {filename=Python}\n# ...\n\n\nclass JackRussellTerrier(Dog):\n    def speak(self, sound=\"Arf\"):\n        return f\"{self.name} says {sound}\"\n\n\n# ...\nNow .speak() is defined on the JackRussellTerrier class with the default argument for sound set to \"Arf\".\nUpdate dog.py with the new JackRussellTerrier class. You can now call .speak() on a JackRussellTerrier instance without passing an argument to sound:\nbash {filename=Python interpreter} &gt;&gt;&gt; miles = JackRussellTerrier(\"Miles\", 4) &gt;&gt;&gt; miles.speak() 'Miles says Arf'\nSometimes dogs make different noises, so if Miles gets angry and growls, you can still call .speak() with a different sound:\nbash {filename=Python Interpreter} &gt;&gt;&gt; miles.speak(\"Grrr\") 'Miles says Grrr'\nOne thing to keep in mind about class inheritance is that changes to the parent class automatically propagate to child classes. This occurs as long as the attribute or method being changed isn’t overridden in the child class.\nFor example, in the editor window, change the string returned by .speak() in the Dog class:\n\n\nPython\n\nclass Dog:\n    # ...\n\n    def speak(self, sound):\n        return f\"{self.name} barks: {sound}\"\n\n\n# ...\n\nNow, when you create a new Bulldog instance named jim, jim.speak() returns the new string:\nbash {filename=Python Interpreter} &gt;&gt;&gt; jim = Bulldog(\"Jim\", 5) &gt;&gt;&gt; jim.speak(\"Woof\") 'Jim barks: Woof'\nHowever, calling .speak() on a JackRussellTerrier instance won’t show the new style of output:\nbash {filename=Python Interpreter} &gt;&gt;&gt; miles = JackRussellTerrier(\"Miles\", 4) &gt;&gt;&gt; miles.speak() 'Miles says Arf'\nSometimes it makes sense to completely override a method from a parent class. But in this case, you don’t want the JackRussellTerrier class to lose any changes that you might make to the formatting of the Dog.speak() output string.\nTo do this, you still need to define a .speak() method on the child JackRussellTerrier class. But instead of explicitly defining the output string, you need to call the Dog class’s .speak() from inside the child class’s .speak() using the same arguments that you passed to JackRussellTerrier.speak().\nYou can access the parent class from inside a method of a child class by using super():\n\n\nPython\n\n# ...\n\n\nclass JackRussellTerrier(Dog):\n    def speak(self, sound=\"Arf\"):\n        return super().speak(sound)\n\n\n# ...\n\nWhen you call super().speak(sound) inside JackRussellTerrier, Python searches the parent class, Dog, for a .speak() method and calls it with the variable sound.\nUpdate dog.py with the new JackRussellTerrier class:\nbash {filename=Python Interpreter} &gt;&gt;&gt; miles = JackRussellTerrier(\"Miles\", 4) &gt;&gt;&gt; miles.speak() 'Miles barks: Arf'\nNow when you call miles.speak(), you’ll see output reflecting the new formatting in the Dog class.\nNote: In the above examples, the class hierarchy is very straightforward. The JackRussellTerrier class has a single parent class, Dog. In real-world examples, the class hierarchy can get quite complicated.\nThe super() function does much more than just search the parent class for a method or an attribute. It traverses the entire class hierarchy for a matching method or attribute. If you aren’t careful, super() can have surprising results."
  },
  {
    "objectID": "reference/docs/python-oop.html#summary",
    "href": "reference/docs/python-oop.html#summary",
    "title": "OOP in Python",
    "section": "6 Summary",
    "text": "6 Summary\nIn this tutorial, you learned about object-oriented programming (OOP) in Python. Many modern programming languages, such as Java, C#, and C++, follow OOP principles, so the knowledge that you gained here will be applicable no matter where your programming career takes you.\nIn Python, you learned how to:\n\nDefine a class, which is a sort of blueprint for an object\nInstantiate a class to create an object\nUse attributes and methods to define the properties and behaviors of an object\nUse inheritance to create child classes from a parent class\nReference a method on a parent class using super()\nCheck if an object inherits from another class using isinstance()"
  },
  {
    "objectID": "reference/docs/course-software.html",
    "href": "reference/docs/course-software.html",
    "title": "Course software",
    "section": "",
    "text": "The operating system running inside the reTerminal is Raspberry Pi OS, which is based on Debian Linux.\nWe will make use of the following tools:\n\nbash and python and related packaging tools\ngit and related configuration\na Unix shell and package manager for installing and managing dependencies compatible with RasperryPi OS\n(later this semester) Azure and GitHub CLI tools\n(later this semester) .NET for interfacing with the App Dev III code\n\nWe will achieve that in one of the following ways, depending on the computer you are using:\n\n(on Windows computers such as the lab computers) by creating a Debian WSL container\n(on OS X computers) using brew\n(on Linux computers) using your system package manager.\n\nSee below for further instructions for each.\n\n\nIf using a Windows machine (lab computers and/or personal) for this course, you will need to set up Windows Subsystem for Linux (WSL).\n\nInstall Debian on WSL\n\nChoosing Debian as the Linux distribution\nSet up Windows Terminal\nSet up VS Code\nSet up git\n\nInstall dependencies:\n\n# Update system:\nsudo apt update && sudo apt upgrade -y\n# Verify python version is &gt;= 3.9: \npython3 --version\n# Ensure pip is installed:\nsudo apt install python3-pip\npip3 --version"
  },
  {
    "objectID": "reference/docs/course-software.html#required-woftware",
    "href": "reference/docs/course-software.html#required-woftware",
    "title": "Course software",
    "section": "",
    "text": "The operating system running inside the reTerminal is Raspberry Pi OS, which is based on Debian Linux.\nWe will make use of the following tools:\n\nbash and python and related packaging tools\ngit and related configuration\na Unix shell and package manager for installing and managing dependencies compatible with RasperryPi OS\n(later this semester) Azure and GitHub CLI tools\n(later this semester) .NET for interfacing with the App Dev III code\n\nWe will achieve that in one of the following ways, depending on the computer you are using:\n\n(on Windows computers such as the lab computers) by creating a Debian WSL container\n(on OS X computers) using brew\n(on Linux computers) using your system package manager.\n\nSee below for further instructions for each.\n\n\nIf using a Windows machine (lab computers and/or personal) for this course, you will need to set up Windows Subsystem for Linux (WSL).\n\nInstall Debian on WSL\n\nChoosing Debian as the Linux distribution\nSet up Windows Terminal\nSet up VS Code\nSet up git\n\nInstall dependencies:\n\n# Update system:\nsudo apt update && sudo apt upgrade -y\n# Verify python version is &gt;= 3.9: \npython3 --version\n# Ensure pip is installed:\nsudo apt install python3-pip\npip3 --version"
  },
  {
    "objectID": "reference/docs/course-software.html#editor",
    "href": "reference/docs/course-software.html#editor",
    "title": "Course software",
    "section": "2 Editor",
    "text": "2 Editor\n\n2.1 Recommended: VS Code\n\nRemote - SSH by Microsoft: Open any folder on a remote machine using SSH and take advantage of VS Code’s full feature set.\nPython language support extension\nPython formatter/linter extension (ruff)"
  },
  {
    "objectID": "reference/docs/course-software.html#cloud",
    "href": "reference/docs/course-software.html#cloud",
    "title": "Course software",
    "section": "3 Cloud",
    "text": "3 Cloud\n\n3.1 Microsoft Azure\n\n\n\n\n\nAzure IoT Hub: Create Using Azure Portal | Build5Nines\n\n\nMicrosoft Azure will be used as the main platform that will:\n\nRegister and connect devices.\nStore and analyse data.\nManage the security layer.\nProvide libraries (SDKs) that can easily be integrated into our code.\nFor more information see Azure IoT page."
  },
  {
    "objectID": "announcements/index.html",
    "href": "announcements/index.html",
    "title": "Announcements",
    "section": "",
    "text": "No matching items\n\n Back to topReuseCC BY-NC 4.0. ©2022-25 Mauricio Buschinelli & Michael Haaf.\n(View License)"
  },
  {
    "objectID": "lectures/index.html",
    "href": "lectures/index.html",
    "title": "All lectures",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Modified - Oldest\n        \n         \n          Modified - Newest\n        \n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nNo matching items\n\n Back to topReuseCC BY-NC 4.0. ©2022-25 Mauricio Buschinelli & Michael Haaf.\n(View License)"
  }
]