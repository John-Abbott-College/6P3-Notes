---
title: "Python project management"
subtitle:
  Previously, we have focused on installing dependencies from other projects --
  we expand on that knowledge to learn how to create our own projects
date: 2025-04-04
categories: ["python"]
bibliography: references.bib
nocite: |-
  @*
---

## Overview

Now that we're making larger applications with multiple dependecies from
different sources, as well as multiple modules, code organization starts to be a
noticable problem. Managing a "project" (for now, a directory containing your
source code for a given task) becomes much easier with tools and configuration.

We'll look at:

- Import statements
- Relative imports
- Configuration with dot files and project files

## Modules vs Packages

*Notes adapted from [@MakingPythonPackage]*

For programmers coming from other languages, how to organize your project files
and how to import modules and classes can be confusing.

Let's clarify the terminology and distinction between a module vs a package.

### Modules

A module usually corresponds to a single file: `something.py` A python "module"
is a single namespace, with a collection of values:

- functions
- constants
- class definitions

### Packages

A “package” is essentially a module, except it can have other modules (and
indeed other packages) inside it.

A package usually corresponds to a directory with a file in it called
`__init__.py` and any number of python files or **other package directories**:

```shell
a_package
	__init__.py
	module_a.py
	a_sub_package/
		__init__.py
	module_b.py
```

`__init__.py` can be empty or it can have arbitrary code.

The code will be run when the package is imported (just like a module).

Modules inside packages are not automatically imported. So, with the above
structure:

```sh
import a_package
```

will run the code in `a_package/__init__.py`

Any names defined in the `__init__.py` will be available in: `a_package.a_name`

## Project Structure

There are two conventions for structuring a python project: **flat** layout and **src** layout.

Flat layout is a bit more intuitive, and most small projects use it.
Src layout has a lot of benefits for larger projects.
The two are compared below.

::: {.panel-tabset}

## flat layout

*example adapted from [@SrcLayoutVsa]*

```sh {filename="example flat layout"}
.
├── .gitignore
├── README.md
├── pyproject.toml
├── some_package/
│   ├── __init__.py
│   └── module.py
└── tools/
    └── some_python_script.py
# More directories can be added; tests, data, utilities, etc.
```

The "flat layout" refers to organising a project’s files in a folder or repository,
such that the various configuration files and import packages are all in the top-level directory.

## src layout

*example adapted from [@SrcLayoutVsa]*

```sh {filename="example src layout"}
.
├── .gitignore
├── README.md
├── pyproject.toml
├── src/
│    └── some_package/
│       ├── __init__.py
│       └── module.py
└── tools/
    └── some_python_script.py
# More directories can be added; tests, data, utilities, etc.
```

The "src layout" deviates from the flat layout by moving the code that is intended to be importable
(i.e. `import some_package`, also known as import packages) into a subdirectory.
This subdirectory is typically named `src/`, hence "src layout".

:::

## Relative Import Statements

*Adapted from StackOverflow discussion [@ayaAnswerRelativeImports2013]*

Consider the project layout below:

```shell
main.py
mypackage/
    __init__.py
    mymodule.py
    myothermodule.py
```

In `mymodule.py` :

```{.python filename=mymodule.py}
# Exported function
def get_temperature():
    return 23.45

if __name__ == '__main__':
    print(get_temperature())
```

In `myothermodule.py` :

```{.python filename=myothermodule.py}
# Relative import using `.` for current directory, `..` for parent directory.
from .mymodule import get_temperature

# Exported function
def announce_weather():
    return f"Outside temperature is {get_temperature()}"

if __name__ == '__main__':
    announce_weather()
```

In `main.py` :

```{.python filename=main.py}
from mypackage.myothermodule import announce_weather

def main():
    print(announce_weather())

if __name__ == '__main__':
    main()
```

This works when running `main.py` or `mypackage/mymodule.py`, but fails with
`mypackage/myothermodule.py`, due to the relative import:

```python
from .mymodule import as_int
```

```
Exception has occurred: ImportError
attempted relative import with no known parent package
```

**Solution**

When running `myothermodule.py` as a stand-alone script, run Python using the
`-m` option to run the file as a module. This will execute all the `__init__.py`
files and load the module dependency.

```python
python -m mypackage.myothermodule

# Note the ".", NOT a "/"
# the following WILL NOT work:
python -m mypackage/myothermodule
```

This will allow you to write modules that contain `main()` functions you can
test separately -- we took advantage of this pattern in Assignment 1.
